#ifndef _ISOTROPIC_COVARIANCE_HPP_
#define _ISOTROPIC_COVARIANCE_HPP_

#include "../util/macros.hpp"
//#include "covseisoslow.hpp"

namespace GP {

template<typename Scalar, template<typename> class Cov>
class Isotropic
{
	friend class Cov<Scalar>;

public:
	// define types and hyperparameters
	TYPE_DEFINE_MATRIX(Scalar);
	TYPE_DEFINE_HYP(Scalar, 2); // log(ell), log(sigma_f)

	/**
	 * @brief	K: Self covariance matrix between the training data.
	 * 			[(K), K* ]: covariance matrix of the marginal Gaussian distribution 
	 * 			[K*T, K**]
	 * @param	[in] logHyp 			The log hyperparameters, log([ell, sigma_f]).
	 * @param	[in] trainingData 	The training data.
	 * @param	[in] pdHypIndex		(Optional) Hyperparameter index.
	 * 										It returns the partial derivatives of the covariance matrix
	 * 										with respect to this hyperparameter. 
	 * 										The partial derivatives are required for learning hyperparameters.
	 * 										(Example) pdHypIndex = 0: pd[K]/pd[log(ell)], pdHypIndex = 1: pd[K]/pd[log(sigma_f)]
	 * 										(Default = -1) K
	 * @return	An NxN matrix pointer.
	 * 			N: The number of training data.
	 */
	static MatrixPtr K(const Hyp &logHyp, TrainingData<Scalar> &trainingData, const int pdHypIndex = -1) 
	{
		assert(pdHypIndex < logHyp.size());

		// derivative w.r.t a hyperparameter
		switch(pdHypIndex)
		{
			// derivative w.r.t log(ell)
			case 0:
			{
				return Cov<Scalar>::dk_dlogell(logHyp, trainingData);
			}

			// derivative w.r.t log(sigma_f)
			case 1:
				{
					MatrixPtr pM = K(logHyp, trainingData);
					(*pM).noalias() = static_cast<Scalar>(2.0) * (*pM);
					return pM;
				}
		}

		// original K

		// constants
		const Scalar sigma_f2	= exp(static_cast<Scalar>(2.0) * logHyp(1));	// sigma_f^2

		// k = sigma_f^2 * f(s)
		MatrixPtr pM = Cov<Scalar>::f(logHyp, trainingData);
		(*pM).noalias() = sigma_f2 * (*pM);
		return pM;
	}

protected:
	//    dk        dk       dl       dk     ds
	// --------- = ---- * -------- = ---- * ---- * l
	//  dlog(l)     dl     dlog(l)    ds     dl
	static MatrixPtr dk_dlogell(const Hyp &logHyp, TrainingData<Scalar> &trainingData)
	{
		// constants
		const Scalar ell = exp(static_cast<Scalar>(1.0) * logHyp(0));	// ell

		// dk_dlog(l) = dk_ds*ds_dl*l
		MatrixPtr pM = Cov<Scalar>::dk_ds(logHyp, trainingData);
		(*pM).alias() = ell*((*pM)->cwiseProduct(*ds_dell(logHyp, trainingData)));
		return pM;
	}

};

}

#endif